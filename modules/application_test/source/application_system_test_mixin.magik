#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug)
##
## This mixin defines given/when/then methods on applications.
##
## All classes that inherits from this mixin must define a
## .properties method that returns a property_list.
##
def_mixin( :application_system_test_mixin, { :serialised_test_mixin, :gui_framework_test_mixin } )
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_application( application_name )
	## 
	## Ensure that the required application (as specified by
	## APPLICATION_NAME) is running.
	##
	##     * If it is already running, the test will run
	##     * If it is available but not yet running, it will be
	##       started and the test will run 
	##     * If it is not available, the test will fail.
	##

	# Make sure there is a queue for events
	_if _self.properties[ :queue ] _is _unset
	_then
		_self.properties[ :queue ] << atomic_queue.new( 1019 )
	_endif
	
	# Make sure the application is running
	_if ( app << smallworld_product.application( application_name ) ) _is _unset
	_then
		_if ( app_def << smallworld_product.application_definition( application_name ) ) _isnt _unset
		_then
			write( "*** Starting application: ", application_name )
			# Application exists but is not yet running, start it
			app << app_def.int!start()
			_self.wait_for_application_to_be_active( application_name )
		_else
			# Application does not exist
			condition.raise( :error, :string, "Cannot find " + application_name + " application" )
		_endif
	_endif

	app.top_frame.maximized? << _self.properties[:frame_maximised?].default(_false)

	app.top_frame.top_canvas_container.add_dependent(_self)
	app.add_dependent(_self)
  
	_self.properties[ :application ] << app

	>> _self 
	
_endmethod
$


_private _method application_system_test_mixin.given_a_case_application( app_name, soc_name )
	## Start Case application with soc name (as specificied by the app_name and soc_name)
	## This would start the application in the given soc_name,
	## skipping the SOC selector dialog. 				

	app_def << smallworld_product.application_definition(app_name)
	new_app_def << application_definition.new(app_def.application_name, app_def.application_class_name, :soc_name, soc_name, _scatter app_def.properties.for_scatter())
	new_app_def.int!start()

	app << new_app_def.application
	
	app.top_frame.maximized? << true
  
	_self.properties[ :application ] << app
	
	_self.wait_for_application_to_be_active(app_name)
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_embbeded_editor( dataset_name, collection_name )
	## 
	##

	collection << _self.dataset( dataset_name ).collections[ collection_name ]
	editor << _self.editor_manager.display_embedded_editor_for_collection( collection )
	_self.properties[ :editor ] << editor

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_embbeded_editor_with_default_values( dataset_name, collection_name )
	## 
	##

	_self.given_an_embbeded_editor( dataset_name, collection_name ).
		 when_clicking_set_defaults_button()
	
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_proposed_editor_values( proposed_values )
	## 
	##

	_self.properties[ :editor ].set_proposed_values( proposed_values )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_a_trail_coordinate( x, y )
	## 
	##

	_self.map_manager.current_map.trail.add_coordinate( coordinate.new( x, y ))

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_empty_trail()
	## 
	##

	_self.map_manager.current_map.trail.empty()

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.given_an_alternative(alt_name,_optional dataset)
	##
	## given_an_alternative() for Core based applications
	## alt_name that is the name of the alternative should be
	## provided by the user in a string e.g. "test_alternative".
	## Tester can optionally provide the dataset name as a symbol
	## e.g. :gis.
	##
	## By default, given_an_alternative will always
	## create alternatives in GIS dataset.
	##
	## Example of method usage would be: given_an_alternative("test", :gis)
	## to create an alternative named test in gis dataset.

	gpm << gis_program_manager
	_if dataset _is _unset
	_then
		ds << gpm.databases[:gis]
	_else
		ds << gpm.databases[dataset]
	_endif

	ds.goto_top_alternative()

	_if ds.has_alternative?(alt_name) _is _false
	_then
		ds.create_alternative(alt_name)
	_endif

	ds.go_to_alternative(alt_name)
	ds.switch(:write)

	>> _self 
	
_endmethod 


_pragma(classify_level=debug)
_method application_system_test_mixin.get_item( id_path )
	## 
	## Return the UI widget matching the supplied string ID_PATH.

	>> sw_swift_manager.get_item_with_path( id_path )
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_inserting_record()
	## 
	##

	_dynamic !current_application!
	!current_application! << _self.properties[ :application ]

	action << _self.insert_action()
	_self.click_action_button( action )

	_self.properties[:new_record] << _self.properties[ :editor ].current_object
	
	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item( id_path, _optional new_frame_wait_time )
	## 
	## Click on the Swift widget identified by the path string ID_PATH.
	##
	## ID_PATH can be found using get_identifier_path() and is
	## displayed in the Object Spy for widgets with a unique
	## identifier path.
	##
	## (Load magik_tools from sw_dev_tools to enable Swift Explorer
	## and activate it using F4 key)

	click_item << _self.get_item( id_path )
	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, new_frame_wait_time )
	_endif
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_action( plugin_name, action_name,
							    _optional new_frame_wait_time )
	## 
	## Click on the ACTION_NAME action of the PLUGIN_NAME plugin.
	## This plugin is a plugin of .properties[ :application ]
	##

	action << _self.properties[ :application ].plugin( plugin_name ).action( action_name )
	_self.click_action_button( action, new_frame_wait_time )

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_tab( tab_name )
	## 
	## 

	container << _self.properties[ :application ].top_frame.top_canvas_container
	
	_for item _over container.get_items_of_type( :tag!sw_tab_container ).fast_elements()
	_loop @item

		_for label_item _over item.tab_container.get_items_of_type( :tag!sw_label_item ).fast_elements()
		_loop
			_if label_item.label = tab_name
			_then
				tab_label << label_item
				tab       << item
				_leave @item
			_endif
		_endloop 
		
	_endloop

	_self.properties[ :tab ] << tab
	_self.properties[ :tab_label ] << tab_label
	
	_self.click_item( tab_label )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_pulldown_menu_item_with_identifier( identifier,
									_optional new_frame_wait_time )
	## Clicks the sw_pulldown_menu_item with IDENTIFIER and adds
	## its .pulldown_menu to .properties[:pulldown_menu]
	##

	_self.when_clicking_item_with_identifier( :tag!sw_pulldown_menu_item, identifier,
						  new_frame_wait_time.default(250) )
	
	_self.properties[ :pulldown_menu ] << _self.properties[ :click_item ].pulldown_menu
	
	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_pulldown_menu( id_path,
									_optional new_frame_wait_time )
	## when_clicking_pulldown_menu_item assumes a tag of
	## tag!sw_pulldown_menu_item and uses an identifier. This
	## method uses an ID path. Adds the .pulldown_menu from the the
	## ID_PATH container to .properties[:pulldown_menu]
	## 

	_self.when_clicking_item( id_path, new_frame_wait_time.default(250) )

	_self.properties[ :pulldown_menu ] << _self.properties[ :click_item ].pulldown_menu

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_with_label( tag, label,
								     _optional container, new_frame_wait_time )
	## 
	##	

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		_if item.responds_to?( :label ) _andif
		    item.label = label
		_then
			click_item << item
			_leave
		_endif
	_endloop

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, new_frame_wait_time )
	_else
		condition.raise(:error, :string, write_string("Failed to find component with label ", label))
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_containing_label( tag, label,
									   _optional container, new_frame_wait_time )
	## 
	##	

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif

	click_item << _unset
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		label_item << item.get_items_with_text( label ).an_element()
		_if label_item _isnt _unset
		_then
			click_item << item
			_leave
		_endif
	_endloop

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, new_frame_wait_time )
	_else
		condition.raise( :error, :string,
				 write_string("Failed to find component with label ", label) )
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_item_with_identifier( tag, identifier,
									  _optional new_frame_wait_time )
	## 
	##
	
	container << _self.properties[ :application ].top_frame.top_canvas_container
	
	_for item _over container.get_items_of_type( tag ).fast_elements()
	_loop
		_if item.identifier = identifier
		_then
			click_item << item
			_leave
		_endif
	_endloop

	_if click_item _isnt _unset
	_then
		_self.click_item( click_item, new_frame_wait_time )
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_in_canvas( id_path, x, y, _optional id )
	## 
	## 

	a_canvas << _unset
	top_con << _self.properties[ :application ].top_frame.top_canvas_container
	
	_for c _over top_con.all_canvases()
	_loop
		_if c.responds_to?( :get_identifier_path|()| ) _andif
		    c.get_identifier_path() = id_path
		_then
			a_canvas << c
			_leave
		_endif
	_endloop
	
	_if id _is _unset
	_then
		id << :left
	_endif
	
	_self.handle_event( a_canvas, :button, id, x, y, :press, 0 )
	_self.handle_event( a_canvas, :button, id, x, y, :release, 0 )

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_going_to_bounds( xmin, ymin, xmax, ymax )
	## 
	##

	bounds << bounding_box.new( xmin, ymin, xmax, ymax )
	_self.map_manager.goto( bounds )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_refreshing_the_map()
	## 
	## Refresh the map and wait for the rendering to complete
	##

	# Add self as a dependent on the render_controller to be able
	# to wait for :end_render
	
	current_map << _self.map_manager.current_map
	n_views << 0
	_for view _over current_map.views()
	_loop
		n_views +<< 1
		view.sys!slot( :controller ).add_dependent( _self )
	_endloop

	_self.when_clicking_item( "application|map_gui_framework.view_refresh" )

	# Wait for each view to finish rendering.  Wait for a maximum
	# of 1 second per view
	_self.remove_value_from_queue( :end_render )
	_for view_index _over range( 1, n_views )
	_loop
		_self.wait_for_value_on_queue( :end_render, _unset, 1000 )
	_endloop

	# Remove the dependencies
	_for view _over current_map.views()
	_loop
		n_views +<< 1
		view.sys!slot( :controller ).remove_dependent( _self )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_clicking_set_defaults_button()
	## 
	## 

	action << _self.properties[ :editor ].component( :field_lister ).action( :set_defaults )

	_self.click_action_button( action )

	>> _self

_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_setting_value_in_text_item( id_path, new_text )
       ## 
       ## Set up Swift widget's VALUE to the NEW_TEXT.
       ## This method can be used to set values in the text fields.
       ## Text field should be ENABLED.
       ##
       ## ID_PATH can be found using get_identifier_path() and is
       ## displayed in the Swift Explorer for widgets with a unique
       ## identifier path.
       ##
       ## NEW_TEXT is string value provided to the Swift widget, 
       ## the widget should be enabled.
       
       item << _self.get_item( id_path )

       # set the NEW_TEXT when ITEM is enabled.       
       _if item.enabled? _is _true
       _then 
       
              item.value << new_text
       _else
              condition.raise( :error, :string, write_string( "Unable to set the text because the item ", item, " is not enabled." ))
       _endif

       >> _self
       
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.when_getting_records( dataset_name, collection_name, properties, id_path )
	## 
	## Get the record(s) based on PROPERTIES.
	## In the Absence of selecting objects from the map, the
	## alternative is to Get the Record in the Editor and Click
	## Select Geometry button.
	## Provide the search critieria as 'Properties'
	##
	## Example: when_getting_records(:electric,  :sub_substation,
	##                              property_list.new_with(:asset_id, "sanity_substation"),
	##                                "<ID Path>")
	##
	
	_self.given_an_embbeded_editor( dataset_name,  collection_name ).
		given_proposed_editor_values( properties ).
		when_clicking_item( id_path )

	# Getting records happen in a separate thread. Wait for the
	# task to complete. 
	_self.remove_value_from_queue( :task_complete )
	_self.wait_for_task_to_complete( :|int!object_editor_get()| )
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_selecting_objects_in_the_map( rwos )
	## 
	## Set the current map selection to RWOS
	##

	geoms << geometry_set.new()
	_for rwo _over rwos.fast_elements()
	_loop
		_for geom _over rwo.all_geometry()
		_loop
			geoms.add( geom )
		_endloop
	_endloop

	_self.properties[ :application ].databus.make_data_available( :set_map_selection, { _unset, geoms })

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.when_going_to_inserted_record()
	## 
	## In the current map view, go to the primary spatial context
	## of the record stored in .properties[:new_record]
	##
	## Raise a condition if:
	## - There is no record in .properties[ :new_record ]
	## - The record does not have a primary spatial context name 
	##

	_if ( record << _self.properties[ :new_record ]) _isnt _unset
	_then
		manager << _self.map_manager
		mv << manager.current_map_view
		app << _self.properties[ :application ]
		
		_if ( sc_name << app.get_primary_spatial_context_name_for( record )) _isnt _unset
		_then 
			sc << app.get_spatial_context_for( record, sc_name )
			mv.goto( sc )
		_else
			condition.raise( :user_error, :string, "No primary spatial context for " + record )
		_endif
	_else
		condition.raise( :user_error, :string, "No record to go to" )
	_endif

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_record_inserted( dataset_name, collection_name, field_name, value )
	## 
	## Find the record in the collection named COLLECTION_NAME with
	## VALUE for the field named FIELD_NAME in the difference
	## stream between the current view and the base view.
	##

	ds_view    << _self.dataset( dataset_name )
	collection << ds_view.collections[ collection_name ]
	
	base_view << ds_view.replicate( :base )
	found?    << _false 

	_protect 

		stream << ds_difference_stream.new_on( collection, base_view.collections[ collection_name ] )

		_loop
			
			( change, record, base_record ) << stream.get()
			_if record _is _unset _then _leave _endif

			_if base_record _is _unset _andif
			    record.perform( field_name ) = value
			_then
				found? << _true
			_endif
			
		_endloop

	_protection
		base_view.discard()
	_endprotect

	fail_str << write_string( "Expected record in ", collection_name, " with field ", field_name, " = ", value, " not found" )
	_self.assert_true( found?, fail_str )

	>> _self 
		
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_masthead_title_is( expected_title )
	## 
	##

	title << _self.properties[ :application ].menubar.masthead_title

	fail_str << write_string( "The expected masthead title is ", newline_char, expected_title, newline_char )
	fail_str << write_string( fail_str, "but it is", newline_char, title )

	_self.assert_equals( expected_title, title, fail_str )

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_dataset_light_is( expected_colour )
	## 
	## EXPECTED_COLOUR is a symbol, either, :red, :orange or :green
	##

	top_container << _self.properties[ :application ].top_frame.top_canvas_container
	
	write_item << top_container.get_item( :db_access_write )
	read_item  << top_container.get_item( :db_access_read  )
	mixed_item << top_container.get_item( :db_access_mixed )

	_if expected_colour _is :red
	_then
		grey_items << property_list.new_with( :green, write_item, :orange, mixed_item )
		red_light  << smallworld_product.get_raster_image( :traffic_light_red, :ui_resources )

		fail_str << "The red light isn't red"
		_self.assert_equals( read_item.image, red_light, fail_str )
		
	_elif expected_colour _is :green
	_then
		grey_items  << property_list.new_with( :red, read_item, :orange, mixed_item )
		green_light << smallworld_product.get_raster_image( :traffic_light_green, :ui_resources )

		fail_str << "The green light isn't green"
		_self.assert_equals( write_item.image, green_light, fail_str )
		
	_else
		grey_items   << property_list.new_with( :green, write_item, :red, read_item )
		orange_light << smallworld_product.get_raster_image( :traffic_light_yellow, :ui_resources )

		fail_str << "The orange light isn't orange"
		_self.assert_equals( mixed_item.image, orange_light, fail_str )
		
	_endif

        grey_light << smallworld_product.get_raster_image( :traffic_light_grey, :ui_resources )
	_for light_name, grey_item _over grey_items.fast_keys_and_elements()
	_loop
		fail_str << write_string( "The ", light_name, " light should be grey, but it isn't" )
		_self.assert_equals( grey_item.image, grey_light, fail_str )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_label_is( expected_string )
	## 
	## 

	editor << _self.properties[ :editor ]
	con << editor.sys!slot(:container)

	collection_string << _if ( a_label_item << con.get_item("collection_name_label") ) _isnt _unset
			     _then
				     >> a_label_item.label
			     _endif
	
	status_string << _if ( a_label_item << con.get_item("status_label") ) _isnt _unset
			 _then
				 >> a_label_item.label
			 _endif
	actual_string << write_string( collection_string, " ", status_string )
	
	_self.assert_equals( expected_string, actual_string )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_field_displays( field_name, expected_string )
	## 
	## 

	# FIXME - should check what is displayed in editor tree_item
	
	editor << _self.properties[ :editor ]
	field_editor << editor.component( :field_lister ).field_editor( field_name )
	
	actual_string << _if ( actual << field_editor.field_item.value ) _isnt _unset
			 _then
				 >> actual.write_string
			 _endif

	fail_str << write_string( "Expected field " + field_name, " to have value '", expected_string,
				  "' not '", actual_string.default(""), "'" )
	_self.assert_equals( expected_string, actual_string, fail_str )
	
	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_editor_fields_display( expected_values )
	## 
	## EXPECTED_VALUES is a property list keyed on field name
	##

	_for field_name, expected_value _over expected_values.fast_keys_and_elements()
	_loop
		_self.then_editor_field_displays( field_name, expected_value )
	_endloop

	>> _self 
	
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_record_is_shown_on_map( rwo )
	## 
	## Verify that the record inserted is available on the main map.

	manager << _self.map_manager
	mv << manager.current_map_view
	geoms << mv.get_visible_geometry_set()

	_self.assert_true( geoms.rwo_set().includes?( rwo ),
			   "Expect current map to show " + rwo.description() )

	>> _self
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.then_dialog_activated( plugin_name, dialog_name )
	## 
	## Verify whether a dialog is active/available on the screen.
	
	a_plugin << _self.properties[ :application ].plugin( plugin_name )
	_if a_plugin _isnt _unset
	_then
		a_dialog << a_plugin.dialogs[ dialog_name ]
	_endif

	_self.add_dialog( a_dialog )
	
	fail_string << write_string( "Dialog: ", dialog_name, " Not found from Plugin: ", plugin_name )
	_self.assert_not_unset( a_dialog, fail_string )

	>> _self  

_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_item_enabled?( id_path, expected_state )
	## 
	## Verify the state of a Swift widget, identified by the 
	## path string ID_PATH, is Enabled or Disabled.
	##
	## ID_PATH can be found using get_identifier_path() and is
	## displayed in the Object Spy for widgets with a unique
	## identifier path.
	##
	## EXPECTED_STATE is enabled? attribute of the Swift widget 
	## which could either _true(Enable) or _false(Disable)

	item << _self.get_item( id_path )
	state << item.enabled?
	fail_string << write_string("Expected State of ", item, " is ", expected_state, " but it is ", state)
	_self.assert_equals(expected_state, state, fail_string)

	>> _self
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_pulldown_menu_has_labels(include_labels)
	##
	## Checks if the pulldown menu in .properties[:pulldown_menu]
	## has child items with the strings in INCLUDE_LABELS

	fail_str << write_string("Pulldown menu missing items")

	missing_labels? << _false
	actual_labels << rope.new()

	_for i_item _over _self.properties[:pulldown_menu].children.fast_elements()
	_loop
		actual_labels.add_last(i_item.label)
	_endloop

	_for i_label _over include_labels.fast_elements()
	_loop
		missing_labels? << _not actual_labels.includes_by_equality?(i_label)

		_if missing_labels?
		_then
			_leave
		_endif
	_endloop 
	
	_self.assert_false(missing_labels?, fail_str)

	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method application_system_test_mixin.then_pulldown_menu_doesnt_have_labels(exclude_labels)
	##
	## Checks if the pulldown menu in .properties[:pulldown_menu]
	## doesn't have child items with the strings in EXCLUDE_LABELS

	fail_str << write_string("Pulldown menu has extra items")

	has_labels? << _false
	
	_for i_item _over _self.properties[:pulldown_menu].children.fast_elements()
	_loop
		has_labels? << exclude_labels.includes_by_equality?(i_item.label)

		_if has_labels?
		_then
			_leave
		_endif 
	_endloop 

	_self.assert_false(has_labels?, fail_str)

	>> _self
	
_endmethod
$



_pragma(classify_level=debug)
_method application_system_test_mixin.scenario_insert_record( dataset_name, collection_name, proposed_values, expected_values )
	## 
	##
	
	>> _self.given_an_embbeded_editor_with_default_values( dataset_name, collection_name ).
		given_proposed_editor_values( proposed_values ).
		
		when_inserting_record().
		when_going_to_inserted_record().

		then_record_is_shown_on_map( _self.parameter_new_record() ).
		then_editor_label_is( _self.parameter_editor_label_inserted() ).
		then_editor_fields_display( expected_values )	
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_new_record()
	## 
	## 

	>> _self.properties[:new_record]
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.wait_for_application_to_be_active( app_name )
	## 
	##
	_for i _over 1.upto(10)
	_loop
		_if (app << smallworld_product.application(app_name)) _isnt _unset _andif
		    app.active?
		_then
			write(write_string("Attempt ",i," successfull - application ",app_name, "is running. Starting test: ",_self.get_name()))
			#We've started.
			_self.properties[ :application ] << app
			_self.wait_for_application_threads_to_finish()
			_leave
		_endif
		_thisthread.sleep(5000)
	_endloop	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.dataset( ds_name )
	##
	## Returns the dataset named DS_NAME
	##

	>> gis_program_manager.databases[ds_name]
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.click_action_button( action,
								    _optional container, new_frame_wait_time )
	## 
	## Look through all the sw_button_items on the application's
	## top container that has :model = ACTION.  Click on the first
	## one found.
	##

	_if container _is _unset
	_then 
		container << _self.properties[ :application ].top_frame.top_canvas_container
	_endif
	
	_for item _over container.all_items()
	_loop
		
		_if ( model << item.model ) = action _orif
		    ( model.is_kind_of?( toolbar_action_proxy ) _andif
		      model.real_subject = action )
		_then
			button << item
			_leave 
		_endif
		
	_endloop

	_self.properties[ :action_button ] << button
	_self.click_item( button, new_frame_wait_time )

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.click_item( item, _optional new_frame_wait_time, x, y )
	## 
	##
	
	_self.properties[ :click_item ] << item

	_if x _is _unset
	_then
		x << ( item.width  / 2.0 ).rounded
	_endif
	_if y _is _unset
	_then
		y << ( item.height / 2.0 ).rounded
	_endif

	top_container << item.top_container
	(top_x, top_y) << item.location_in_window( top_container )
	
	x +<< top_x
	y +<< top_y

	_self.handle_event( top_container, :locator, :move, x, y, _unset, _unset )
	_self.handle_event( top_container, :button, :left, x, y, :press, 0 )

	_if new_frame_wait_time _isnt _unset
	_then
		_self.remove_value_from_queue( :frame_active )
		frame.add_dependent( _self, :frame_active )
	_endif
	
	_self.handle_event( top_container, :button, :left, x, y, :release, 0 )

	_if new_frame_wait_time _isnt _unset
	_then
		_self.wait_for_value_on_queue( :frame_active, _false, new_frame_wait_time )
		frame.remove_dependent( _self )
	_endif
	
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.handle_event( a_canvas, category, id, x, y, func, modmask,
							     _optional second_id )
	## 
	##

	a_canvas.add_dependent( _self )

	time << system.elapsed_seconds()
	new_event << input_event.new_with( category, time, a_canvas.actual.id, id, x, y, func, modmask )
	new_event.second_id << second_id

	_if category _is :locator _andif
	    id _is :move _andif 
	    _not a_canvas.has_focus?
	_then
		a_canvas.top_frame.activate()
		_self.wait_for_event_on_queue( :event_handled, :visible )
	_endif

	a_canvas.handle_event( new_event )

	_self.wait_for_event_on_queue( :event_handled, id )

	a_canvas.remove_dependent( _self )
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.map_manager
	## 
	## 

	>> _self.properties[ :application ].get_service_provider( :map_manager )
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.editor_manager
	## 
	## 

	>> _self.properties[ :application ].get_service_provider( :editor_manager )
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.parameter_unique_id_string( id, prefix )
	## 
	## Set the .properties[ ID ] to "PREFIX" +
	## system.elapsed_seconds()
	##

	_if _self.properties[ id ] _is _unset
	_then 
		_self.properties[ id ] << write_string( prefix, system.elapsed_seconds().as_fixed_string( 10, 10 ))
	_endif

	>> _self.properties[ id ]
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_editor_label_inserted()
	## 
	## Return a string with the expected string for the editor when
	## a record is inserted.
	##
	## This is based on the current record:
	## [<dataset_name>] <collection_name> - record inserted
	##

	>> write_string( _self.editor_label(), " - record inserted" )
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_editor_label_updated()
	## 
	## Return a string with the expected string for the editor when
	## a record is updated.
	##
	## This is based on the current record:
	## [<dataset_name>] <collection_name> - record updated
	##

	>> write_string( _self.editor_label(), " - record updated" )
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.editor_label()
	## 
	##
	
	record << _self.parameter_new_record()
	label  << write_string( "[", record.source_view.external_name, "] ", record.external_name )

	>> label 
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.parameter_pulldown_menu_container
	## 
	##

	_if ( menu << _self.properties[ :pulldown_menu ] ) _isnt _unset
	_then
		_return menu.top_container
	_endif
	
_endmethod
$


_pragma(classify_level=debug)
_private _method application_system_test_mixin.insert_action()
	## 
	## Return the insert action on the editor.
	##
	## This is the action named :insert
	##
	
	>> _self.properties[ :editor ].action( :insert )
	
_endmethod
$

_pragma(classify_level=debug)
_private _method application_system_test_mixin.close_dialogs()
	## 
	## Close any dialogs that are listed in the properties
	## [:dialogs ] slot
	##

	dialogs << _self.properties[ :dialogs ]
	_if dialogs _isnt _unset
	_then
		_for dialog _over dialogs.elements()
		_loop
			dialog.close()
		_endloop
	_endif 
	
_endmethod
$

_pragma(classify_level=debug)
_private _method application_system_test_mixin.add_dialog( a_dialog )
	## 
	## Add A_DIALOG to the properties
	## [:dialogs ] slot
	##

	_if _self.properties[ :dialogs ] _is _unset
	_then 
		_self.properties[ :dialogs ] << rope.new()
	_endif 

	_if a_dialog _isnt _unset
	_then 
		_self.properties[ :dialogs ].add( a_dialog )
	_endif 
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method application_system_test_mixin.wait_for_threads_to_finish( task_owner )
	## 
	## Wait for all the tasks on TASK_OWNER to finish.
	##
	## Wait for 1 second and check if TASK_OWNER.thread_pool is
	## empty.
	##

	_loop
		_if task_owner.task_runner().thread_pool.empty? _then _leave _endif
		_thisthread.sleep( 1000 )
	_endloop 
	
_endmethod
$

_private _method application_system_test_mixin.wait_for_application_threads_to_finish()
	

	_self.wait_for_threads_to_finish( _self.properties[ :application ] )
	_self.wait_for_threads_to_finish( _self.properties[ :application ].top_frame.top_canvas_container )

_endmethod 
$


_pragma(classify_level=debug)
_method application_system_test_mixin.get_components( _optional a_string, a_component, module_name )
	## 
	## Returns a rope of components with a name or class name
	## matching A_STRING in the component A_COMPONENT.
	##
	## All open applications will be searched if A_COMPONENT is not
	## provided.
	## All components will be returned if A_STRING is not provided.
	##
	## If MODULE_NAME is provided the results are restricted to
	## modules matching that name.
	##
	## Example of use (with PNI user app open):
	##  get_components("editor")
	##    1    a topology_editor_plugin(topology)
	##    2    a editor_activator_pi(editor_activator)
	##    3    a pni_editor_manager(editor_manager)
	##    4    a editor_viewer(embedded_viewer)
	##    5    a pni_editor_manager(editor_manager)
	##    sw:rope:[1-5]
	##
	##  get_components("con menu")
	##    1    a connectivity_menu_plugin(connectivity_menu)
	##    2    a connectivity_menu_framework(connectivity_menu)
	##    sw:rope:[1-2]
	##
	##  get_components("app man")
	##    1    a pni_application_manager(application_manager)
	##    sw:rope:[1-1]
	##
	##  Return all components of the PNI application:
	##  app << smallworld_product.application(:pni)
	##  get_components( _unset, app )
	##

	test_string << _proc( a_string )

			       _if a_string _is _unset
			       _then
				       _return
			       _endif
			       
			       _for i, c _over a_string.fast_keys_and_elements()
			       _loop
				       _if c _is %space
				       _then
					       a_string[i] << %*
				       _endif
			       _endloop
			       
			       end << a_string.size
			       
			       a_stream << internal_text_output_stream.new()
			       _if a_string[1] _is %^
			       _then
				       start << 2
			       _else
				       a_stream.put( %* )
				       start << 1
			       _endif
			       _if a_string[end] _is %$
			       _then
				       a_stream.write( a_string.slice(start, end - 1) )
			       _else
				       a_stream.write( a_string.slice(start, end) )
				       a_stream.put( %* )
			       _endif
			       
			       _return a_stream.string
		       _endproc

	a_string << test_string( a_string )
	module_name << test_string( module_name )
	
	results << rope.new()
	done << set.new()

	a_queue << queue.new()

	_if a_component _isnt _unset
	_then
		a_queue.add( a_component )
		done.add( a_component )
	_else
		_for app _over smallworld_product.applications.fast_elements()
		_loop
			a_queue.add( app )
			done.add( app )
		_endloop
	_endif
	
	types << property_list.new_with( :gui, _false )

	_loop
		_if a_queue.empty? _then _leave _endif
		
		c << a_queue.next()

		_if ( a_string _is _unset _orif
		      c.class_name.write_string.matches?( a_string ) _orif
		      ( c.responds_to?( :name ) _andif
			c.name _isnt _unset _andif
			c.name.write_string.matches?( a_string ) ) ) _andif
		    ( module_name _is _unset _orif
		      c.module_name.write_string.matches?( module_name ) )
		_then
			results.add_last( c )
		_endif
		
		rel_items << _self.get_related_items( c, types )
		
		_for r _over rel_items.fast_elements()
		_loop
			_if _not done.includes?( r )
			_then
				a_queue.add( r )
				done.add( r )
			_endif
		_endloop
	_endloop
	
	>> results
_endmethod
$


_pragma(classify_level=debug)
_method application_system_test_mixin.get_related_items( obj, _optional types )
	## 
	## Returns a set of objects related to the object OBJ.
	##
	## TYPES controls what relationships are considered and should
	## be a property list with relationship name and boolean pairs.
	## By default all types are included.
	##
	## Supported relationships are:
	##  :slots
	##  :components
	##  :framework
	##  :dialogs
	##  :gui
	##  :gui_owner
	##  :dependents
	##  :action_engine
	##
	## Example of use:
	##  app << smallworld_product.applications.an_element()
	##  get_related_items( app, property_list.new_with(:gui, _false) )
	##

	_if types _is _unset
	_then
		types << property_list.new()
	_endif
	
	others << set.new()

	gui? << types[:gui] _isnt _false
	
	_if types[:slots] _isnt _false _andif
	    obj.responds_to?( :|sys!slot_names_and_values()| )
	_then
		obj_mod_name << obj.module_name
		_for slot_name, slot_value _over obj.sys!slot_names_and_values()
		_loop
			_if slot_value.is_kind_of?( sw_component ) _orif
			    ( gui? _andif slot_value.responds_to?( :|tag!sw_item_base| ) ) _orif
			    slot_value.module_name _is obj_mod_name
			_then
				others.add( slot_value )
			_endif
		_endloop
	_endif

	_if types[:components] _isnt _false _andif
	    obj.responds_to?( :components|()| )
	_then
		_for c _over obj.components()
		_loop
			others.add( c )
		_endloop
	_endif
	
	_if types[:framework] _is _true _andif
	    obj.responds_to?( :framework ) _andif
	    obj.framework _isnt _unset
	_then
		others.add( obj.framework )
	_endif
	
	_if types[:dialogs] _isnt _false _andif
	    ( obj.is_kind_of?( gui_framework ) _orif
	      obj.is_kind_of?( plugin ) )
	_then
		_for name, a_dialog _over obj.sys!slot(:dialogs).fast_keys_and_elements()
		_loop
			_if a_dialog _isnt _unset
			_then
				others.add( a_dialog )
			_endif
		_endloop
	_endif
	
	_if types[:dependents] _isnt _false
	_then
		_for d _over obj.dependents()
		_loop
			_if d.is_kind_of?( sw_component ) _orif
			    ( gui? _andif d.responds_to?( :|tag!sw_item_base| ) )
			_then
				others.add( d )
			_endif
		_endloop
	_endif
	
	_if types[:action_engine] _isnt _false _andif
	    obj.responds_to?( :|tag!sw_item_base| )
	_then
		_if ( a_model << obj.model ) _isnt _unset
		_then
			others.add( a_model )
			_if a_model.is_kind_of?( sw_action ) _andif
			    ( an_engine << a_model.engine ) _isnt _unset
			_then
				others.add( an_engine )
			_endif
		_endif
	_endif

	_if types[:gui_owner] _isnt _false _andif
	    obj.responds_to?( :|tag!sw_item_base| ) _andif
	    obj.responds_to?( :|get_gui_owner()| ) _andif
	    ( owner << obj.get_gui_owner() ) _isnt _unset
	_then
		others.add( owner )
	_endif
	
	>> others
_endmethod
$

