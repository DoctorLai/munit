#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug)
##
## This mixin defines given/when/then methods for designs.
##
## All classes that inherits from this mixin must define a
## .properties method that returns a property_list.
##
## Method get_or_create_project() may create a new project for
## the design. The state model use will default to the first
## one found unless it is explicitly specified.
##
## The state model to use can be specified in one of two ways:
## - call given_a_state_model( name ) will cached the supplied
## name in .properties[:state_model_name] OR
## - redefine the constant default_job_type on the subclass
##
## If the state model name is not explicitly configured, then
## the standard DM behaviour applies:
## the project will pick up a state model from 
## (swg_dsn_project.configuration[:state_model] and if this
## gives no valid model, will just pick an_element() from the
## state model table
def_mixin( :design_manager_system_test_mixin, { :application_system_test_mixin } )
$


_pragma(classify_level=debug, usage=subclassable)
## Defines the Job type for the project - used to look up the
## state model. Can be subclassed.
design_manager_system_test_mixin.define_shared_constant( :default_state_model_name, _unset, :public )
$

_pragma(classify_level=debug)
_method design_manager_system_test_mixin.given_no_active_design()
	## 
	##
	
	swg_dsn_admin_engine.clear_current_design()

	>> _self
	
_endmethod
$

_pragma(classify_level=debug)
_method design_manager_system_test_mixin.given_a_state_model( state_model_name )
	##
	## STATE_MODEL_NAME is the name of the state model you want to
	## use for a new project.
	## Sets .properties[:state_model_name]

	_self.properties[:state_model_name] << state_model_name
_endmethod
$

_pragma(classify_level=debug)
_method design_manager_system_test_mixin.given_a_design( project_name, design_name, _optional xmin, ymin, xmax, ymax )
	## 
	## If a design with DESIGN_NAME exists, use it, else create a
	## new one.
	##
	
	_if ( design << _self.get_existing_test_design( project_name, design_name )) _is _unset
	_then
		_self.given_a_new_design( project_name, design_name, xmin, ymin, xmax, ymax )		
	_else
		_self.activate_design( design )

		_self.properties[ :design  ] << design
		_self.properties[ :project ] << design.project
		
	_endif

	>> _self 
	
_endmethod
$



_pragma(classify_level=debug)
_method design_manager_system_test_mixin.given_a_new_design( project_name, design_name, _optional xmin, ymin, xmax, ymax )
	##
	## Create a new design with name DESIGN_NAME in the project
	## with name PROJECT_NAME  which can be either new or an
	## existing project.
	## This method will fail if a design with DESIGN_NAME exists
	## already.
	##
	## See method get_or_create_project() for argument description
	
	parent_design << swg_dsn_admin_engine.active_scheme

	_try _with cond
		
		swg_dsn_admin_engine.clear_current_design()

		project << _self.get_or_create_project( project_name, xmin, ymin, xmax, ymax )
		views   << _self.ds_view_names
		swg_dsn_admin_engine.get_admin_view().commit()
		design  << swg_dsn_admin_engine.create_scheme( project, parent_design, design_name, views, _unset )
		
		_self.activate_design( design )
		
	_when ds_write_switch_failed
		# We ought to be able to use the :view parameter of the
		# condition, but this doesn't get set :-(
		_local view << swg_dsn_admin_engine.get_admin_view()
		write( "Failed to get write access to to view ", view, " as it is being written to by ", view.current_writer )
		cond.continue_handling()
	_endtry

	_self.properties[ :design  ] << design
	_self.properties[ :project ] << design.project

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_system_test_mixin.given_no_active_design()
	## 
	##
	
	swg_dsn_admin_engine.activate_design( _unset )
	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_system_test_mixin.when_changing_design_status( new_status )
	## 
	## Change the status of the current design to NEW_STATUS
	##

	design << swg_dsn_admin_engine.active_scheme	

	_if (design.status <> new_status)
	_then 	
		swg_dsn_admin_engine.find_and_perform_transition( design, design.status, new_status )
	_endif

	>> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method design_manager_system_test_mixin.scenario_create_design( xmin, ymin, xmax, ymax, project_name, design_name, new_status, dataset_light )
	## 
	## Create a writable design.  An application must be running
	## before executing this scenario.
	##
	## GIVEN an application is running
	##  
	## WHEN I create a design with 
	##  Name="<PROJECT_NAME>"
	##  Type="<TYPE>"
	##  Bounds=(<XMIN,YMIN,XMAX,YMAX>)
	## AND I transitioned the Design to "<NEW_STATUS>"
	##
	## THEN Masthead_title= "<_self.masthead_title>"
	##  AND Dataset Light=<DATASET_LIGHT>
	##
			
	>> _self.given_no_active_design().
		when_going_to_bounds( xmin, ymin, xmax, ymax ).
		given_a_new_design( project_name, design_name ).
		when_changing_design_status( new_status ).
		then_masthead_title_is( _self.parameter_masthead_title ).
		then_dataset_light_is( dataset_light )
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.get_existing_test_design( project_name, design_name )
	##
	## Returns the test design if it exists and _unset otherwise
	##

	>> swg_dsn_admin_engine.find_scheme( design_name, project_name, _false )
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.get_or_create_project( project_name, xmin, ymin, xmax, ymax )
	## 
	## Create a new project record with PROJECT_NAME and bounds
	## given by XMON,YMON,XMAX,YMAX.
	
	project << swg_dsn_admin_engine.find_project_or_scheme( project_name, :project, _false )
	_if project _is _unset 
	_then
		
		_if xmin _isnt _unset
		_then
			bounds << bounding_box.new( xmin, ymin, xmax, ymax )
		_else
			manager << _self.properties[ :application ].get_service_provider( :map_manager )
			bounds  << manager.current_map_view.current_view_bounds
		_endif
		job_attributes << property_list.new_with(:job_type, _self.properties[:state_model_name].default( _self.default_state_model_name ) )
		project  << swg_dsn_admin_engine.create_project( project_name, _self.ds_view_names, bounds.as_sector_rope(), job_attributes )
		
	_endif

	>> project
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.ds_view_names
	## 
	##	
		
	dataset_names << rope.new()
	_for dataset _over swg_dsn_admin_engine.dm_managed_datasets().fast_elements()
	_loop
		dataset_names.add_last( dataset.name )
	_endloop

	>> dataset_names
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.parameter_masthead_title
	## 
	## This method should be subclassed to provide the correct
	## masthead title for the application the test is testing.
	##

	>> ""
	
_endmethod
$


_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.delete_project()
	## 
	## Delete the project and designs created by this test.
	##
	## This method can be called in the tear_down() method of tests
	## inheriting from this mixin.
	##

	# Wait for all GUI and application threads to finish
	_self.wait_for_application_threads_to_finish()
	
	_if ( project << _self.properties[ :project ] ) _isnt _unset
	_then
		swg_dsn_admin_engine.activate_design( _unset )
		swg_dsn_admin_engine.delete_project( project, _true )
		swg_dsn_admin_engine.rollforward()
	_endif
	
_endmethod
$





_pragma(classify_level=restricted,topic=MUnit)
_private _method design_manager_system_test_mixin.activate_design( design )
	## 
	##
	
	swg_dsn_admin_engine.activate_design( design )
	
_endmethod
$
