#% text_encoding = iso8859_1
_package sw

_pragma(classify_level=debug)
##
## Top level test_case class providing infrastructure for tests
## that require an application to be running.
##
## This class provides a framework for writing tests that
## require an database, but not an application, to be running
## by implementing the following behaviour:
##
## * set_up() 
##   * ensure that there is a database
##   * ensure that the database is writable 
##     * It creates an in-memory scratchpad in any
##       datasets (as specified by dataset_names) in which the test
##       will make any changes.  
## * tear_down() 
##   * Remove the scratchpad so the dataset reverts to its original state. 
##
## Subclasses of database_test should implement the following methods:
##
## * writable_dataset_names - This should return the names of any datasets that need to be writable. 
##
## database_test provides the following API methods:
##
## * dataset( ds_name ) - This returns the dataset identified by ds_name  
##
def_slotted_exemplar( :database_test,
        {
		{ :properties,   _unset },
		{ :datasets,     _unset }
	},
        { :test_case, :database_system_test_mixin } )
$

database_test.define_shared_constant(:test_aspects,
	property_list.new_with(:never, "never"), :public )
$

_pragma(classify_level=debug)
database_test.define_shared_variable(:database_path,
        ##
        ## The location of the cambridge_db to use.
        ##
        "cbgsun11:/swdev/databases/dev_ds_420/ds/ds_admin", :public)
$


_pragma(classify_level=debug)
database_test.define_shared_variable(:concurrency_mode,
        ##
        ## The concurrecny_mode used to reference the database. This
        ## may be :single_user or :multi_user. The default is :multi_user.
        ##
        :multi_user, :public)
$

database_test.method_table.resolve_conflicts( :test_case )
$

_pragma(classify_level=debug)
_method database_test.properties
	## 
	##

	>> .properties
	
_endmethod
$


_pragma(classify_level=debug, usage={subclassable})
_method database_test.writable_dataset_names
	## 
	## A vector containing the names of any datasets that need to
	## be writable.
	##
        >> {}
_endmethod 
$        

_pragma(classify_level=debug, usage={subclassable})
_method database_test.other_dataset_names
        ##
        ## The names of any datasets which aren't in the normal SOC (eg case)
        ##
        >> {}
_endmethod 
$

_pragma(classify_level=debug)
_method database_test.one_time_set_up()
	##
	## This gets called before first test in this test class and
	## ensures that the correct database is available. 
	## It also creates a scratchpad to hold any transient data.
        ##
        ## Subclass implemetations should always call _super.
	##
        _super.one_time_set_up()
        _self.check_correct_database_open()
_endmethod
$

_pragma(classify_level=debug)
_method database_test.one_time_tear_down()
	##
	## This gets called before first test in next test class and
	## ensures that the database opened in this test is discarded.
	##
        ## Subclass implemetations should always call _super.
	##
        _super.one_time_tear_down()
        gis_program_manager.reinitialise()
_endmethod
$

_pragma(classify_level=debug)
_method database_test.set_up()
	##
	## This gets called before each test and ensures that the
	## correct database is available. 
	## It also creates a scratchpad to hold any transient data.
        ##
        ## Subclass implemetations should always call _super.
	##
        _super.set_up()
	.properties << property_list.new()
	_self.given_writable_datasets( _self.writable_dataset_names )
_endmethod
$

_private _method database_test.check_correct_database_open()
        ## 
        ## If there is no database open, then opens the nominated
        ## one. If one is open but it isn't the correct one (the ace
        ## path is incorrect) then closes that and opens the correct
        ## one.
        ##
        _if _not ds_environment.c_is_initialised? _orif
            gis_program_manager.ace_top_view _is _unset _orif
            gis_program_manager.ace_top_view.searchpath.at_using_default("", 1) <> _self.database_path _orif
            ds_environment.concurrency_mode <> _self.concurrency_mode
        _then 
                #
                # Suppress witterage. Note that
                # raw_swdp_manager.open_partition() forcibly witters to
                # !terminal! and that easily can't be suppressed without hiding
                # real errors. 
                #
                _handling information _with procedure 
                _handling warning _with procedure
                ds_environment.concurrency_mode << _self.concurrency_mode
                smallworld_product.set_startup_option(:login, "root")

                gis_program_manager.reinitialise()
                open_database({_self.database_path})
        _endif

        _self.open_other_datasets()
_endmethod
$


_pragma(classify_level=debug)
_method database_test.tear_down()
	##
	## This gets called after each test and deletes the scratchpad.
	##

	_super( test_case ).tear_down()
	_self.close_datasets()
	
_endmethod
$

_pragma(classify_level=debug)
_method database_test.open_other_datasets()
        ##
        ## Open any datasets used by the case tool
        ##
        _for name _over _self.other_dataset_names.elements()
        _loop 
                _if gis_program_manager.databases[name] _is _unset
                _then gis_program_manager.open_datasets(name)
                _endif 
        _endloop 
_endmethod 
