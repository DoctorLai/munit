#% text_encoding = iso8859_1
_package sw
$

def_slotted_exemplar( :remote_test_suite,
	{
		{ :connection,   _unset },
		{ :thread,       _unset },
		{ :port,         _unset },
		{ :remote_tests, _unset },
		{ :clients,      _unset }
	},
	{ :test_suite } )
$


_pragma(classify_level=debug)
_method remote_test_suite.new( port, _gather test_product_names )
	## 
	##

	>> _clone.init( port, test_product_names )
	
_endmethod
$


_pragma(classify_level=debug)
_method remote_test_suite.init( port, test_product_names )
	##
	##

	_super.init()

	.port << port
        .connection << tcpip_connection_stream.new( port )
	.remote_tests << rope.new()
	.clients << rope.new()

        _if .connection _is _unset
        _then
                condition.raise( :error, :string, "No connection stream created on " + port )
        _endif

	_for test_product_name _over test_product_names.fast_elements()
	_loop
		_self.add_product_test_suite( test_product_name )
	_endloop
        
        .thread << _proc @remote_test_suite( me )
                           me.listen()
                   _endproc.fork_at( _thisthread.maximum_priority, _self )
        >> _self
	
_endmethod
$


_pragma(classify_level=debug)
_method remote_test_suite.close_server()
        ## Closes down the server listener. Note that this does not
        ## shut down any client connections.

	_for client _over .clients.fast_elements()
	_loop
		_self.send_module_name_to_client( :done, client )
	_endloop
        
        _if .connection _isnt _unset
        _then
                conn << .connection ^<< _unset
                conn.close()
        _endif
	
_endmethod
$


_pragma(classify_level=debug)
_method remote_test_suite.listen()
	##
	##
	
        write( _self.class_name, " listening on ", .port )
        conn << .connection
        inc << system.incarnation
        
        _loop
                _try _with cond
                        # Ensure this loop terminates correctly on image restart with
                        # active client
                        client << _unset
                        client << conn.get()
                _when stream_is_closed
                        # Generally occurs on image restart
                        _if inc _is system.incarnation
                        _then
                                cond.invoke()
                        _endif
                _endtry
                
                _if client _is _unset _then _leave _endif

		.clients.add_last( client )
                _self.run_tests_in_client( client )
        _endloop
_endmethod
$


_pragma(classify_level=debug)
_private _method remote_test_suite.run_tests_in_client( client )
	## 
	##

	_proc( client, me )

		_loop
			_try 
				# Wait for the client to request a test
				nchars  << client.input.get_signed_int()
				_if nchars _is _unset
				_then
					_thisthread.sleep( 100 )
				_else 
					message << client.input.get_ascii_chars( nchars ).as_symbol()
					
					_if message _is :test_to_run
					_then
						
						( module_name, test_name ) << me.get_test_to_run()
						
						me.send_module_name_to_client( module_name, client )
						
						_if module_name _is :done _then _leave _endif
						
						client.output.put_signed_int( test_name.size )
						client.output.put_ascii_chars( test_name )
						client.output.flush()
						
					_endif
				_endif

			_when generic_prim_failure # Client died, stop listening for requests for new tests
				_leave 
			_endtry 

		_endloop
		
	_endproc.fork( client, _self )
	
_endmethod
$


_pragma(classify_level=debug)
_method remote_test_suite.get_test_to_run()
	## 
	##

	_lock .remote_tests
	      _if .remote_tests.empty?
	      _then
		      module_name << :done
	      _else 
		      test << .remote_tests.remove_first()
		      module_name << test.module_name
		      test_name   << test.class_name
	      _endif
	_endlock

	>> ( module_name, test_name )
	
_endmethod
$


_pragma(classify_level=debug)
_method remote_test_suite.send_module_name_to_client( module_name, client )
	## 
	##
	
	client.output.put_signed_int( module_name.size )
	client.output.put_ascii_chars( module_name )
	client.output.flush()
	
_endmethod
$


_pragma(classify_level=debug)
_private _method remote_test_suite.add_product_test_suite( product_name )
	## 
	##

	tests <<  product_test_suite.new( product_name )

	_lock .remote_tests
	      _for module_test _over tests.tests()
	      _loop
		      _for test_case _over module_test.tests()
		      _loop
			      .remote_tests.add_last( test_case )
		      _endloop
	      _endloop
	_endlock
	
_endmethod
$
